" This file is autogenerated. DO NOT EDIT. Changes will be lost.
" Generator: vxlib/plugin.py
"if vxlib#plugin#StopLoading('_plugin_autogen_0b32a0:11415')
"   finish
"endif

let s:exception_list = []
function! s:Exception(throwpoint, exception, plugid, loadstatus)
 if a:loadstatus != 0
  call vxlib#plugin#SetLoaded(a:plugid, a:loadstatus)
 endif
 call add(s:exception_list, matchstr(a:throwpoint, ',\s*\zsline\s\+\d\+') . ' (' . a:plugid . '):')
 call add(s:exception_list, '   ' . a:exception)
 let g:VxPluginErrors[a:plugid] = a:exception
endfunc

function! s:StrHas(ftrlist)
 let ftrs=split(a:ftrlist, ',')
 let hftrs=[]
 for f in ftrs
  call add(hftrs, (has(f) ? '+' : '-') . f)
 endfo
 return join(hftrs, ' ')
endfunc
function! s:CheckSetting(name, default)
 call vxlib#plugin#CheckSetting(a:name, a:default)
endfunc

function! s:IsEnabled(name)
 return vxlib#plugin#IsEnabled(a:name)
endfunc

function! s:GetLoadStatus(name)
 return vxlib#plugin#GetLoadStatus(a:name)
endfunc

function! s:SetLoaded(name, value)
 return vxlib#plugin#SetLoaded(a:name, a:value)
endfunc

function! s:SetEnabledDefault(name, value)
 if ! has_key(g:VxPlugins, a:name)
  call vxlib#plugin#SetEnabled(a:name, a:value)
 endif
endfunc

function! s:ContinueLoading(name)
 if ! vxlib#plugin#IsEnabled(a:name)
  call vxlib#plugin#SetLoaded(a:name, -1)
 elseif ! vxlib#plugin#GetLoadStatus(a:name)
  return 1
 endif
 return 0
endfunc

" ================================
" Source: vxlib/cmd.vim
" START Plugin
let s:curplugin='vxlib#quickfixpreview'
if s:ContinueLoading(s:curplugin)
 if !(has('windows')&&has('quickfix'))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'windows&&quickfix: ' . s:StrHas('quickfix,windows')
 else
  try        
   autocmd FileType qf call vxlib#cmd#PrepareQFixPreview()

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxbuflist.vim
" START Plugin
let s:curplugin='vimuiex#vxbuflist'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   let g:VxPluginVar.vxbuflist_mru = []
   function s:VIMUIEX_buflist_pushBufNr(nr)
    " mru code adapted from tlib#buffer
    let lst = g:VxPluginVar.vxbuflist_mru
    let i = index(lst, a:nr)
    if i > 0  | call remove(lst, i) | endif
    if i != 0 | call insert(lst, a:nr) | endif
   endfunc

   augroup vxbuflist
    autocmd BufEnter * call s:VIMUIEX_buflist_pushBufNr(bufnr('%'))
   augroup END
   command VxBufListSelect call vimuiex#vxbuflist#VxBufListSelect()

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxcapture.vim
" START Plugin
let s:curplugin='vimuiex#vxcapture'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   command -nargs=+ -complete=command VxCmd call vimuiex#vxcapture#VxCmd_QArgs(<q-args>)
   command VxMarks call vimuiex#vxcapture#VxMarks()
   command VxDisplay call vimuiex#vxcapture#VxDisplay()
   command -nargs=+ VxMan call vimuiex#vxcapture#VxMan_QArgs(<q-args>)

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxdired.vim
" START Plugin
let s:curplugin='vimuiex#vxdired'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   call s:CheckSetting('g:VxRecentFile_nocase', !has('fname_case'))
   call s:CheckSetting('g:VxRecentDir_size', 20)
   call s:CheckSetting('g:VxFileFilter_treeDepth', 6)
   call s:CheckSetting('g:VxFileFilter_skipFiles', "'*.pyc,*.o,*.*~,*.~*,.*.swp'")
   call s:CheckSetting('g:VxFileFilter_skipDirs', "'.git,.svn'")
   call s:CheckSetting('g:VxFileFilter_limitCount', 0)
   call s:CheckSetting('g:VxFileBrowser_skipFiles', 'g:VxFileFilter_skipFiles')
   call s:CheckSetting('g:VxFileBrowser_skipDirs', "''")

   function! s:VIMUIEX_dired_SaveHistory()
    let g:VXRECENTDIRS = join(g:VxPluginVar.vxrecentfile_dirs, "\n")
   endfunc

   function! s:VIMUIEX_dired_AutoMRU(filename) " based on tmru.vim
    if ! has_key(g:VxPluginVar, 'vxrecentfile_dirs') | return | endif
    if &buflisted && &buftype !~ 'nofile' && fnamemodify(a:filename, ':t') != ''
     let dir = fnamemodify(a:filename, ':p:h')
     let dirs = g:VxPluginVar.vxrecentfile_dirs
     let idx = index(dirs, dir, 0, g:VxRecentFile_nocase)
     if idx == -1 && len(dirs) >= g:VxRecentDir_size
      let idx = g:VxRecentDir_size - 1
     endif
     if idx > 0  | call remove(dirs, idx) | endif
     if idx != 0 | call insert(dirs, dir) | endif
    endif
   endf

   augroup vxdired
    autocmd!
    autocmd BufWritePost,BufReadPost  * call s:VIMUIEX_dired_AutoMRU(expand('<afile>:p'))
    autocmd VimLeavePre * call s:VIMUIEX_dired_SaveHistory()
   augroup END


   command VxFileBrowser call vimuiex#vxdired#VxFileBrowser('browse')
   command VxFileFilter call vimuiex#vxdired#VxFileBrowser('filter')

   " STARTUP
   function! s:G_vimuiex_vxdired_auto_startup()
    try
     autocmd! G_vimuiex_vxdired_auto_onetime        
     call s:CheckSetting('g:VXRECENTDIRS', '""')
     let g:VxPluginVar.vxrecentfile_dirs = split(g:VXRECENTDIRS, "\n")
    catch /.*/
     call s:Exception(v:throwpoint, v:exception, 'Startup: vimuiex#vxdired', 0)
    endtry
   endfunc
   augroup G_vimuiex_vxdired_auto_onetime
    autocmd!
    autocmd BufWinEnter,VimEnter *
       \ call s:G_vimuiex_vxdired_auto_startup()
       \ | delfunc s:G_vimuiex_vxdired_auto_startup
   augroup END
   " END-STARTUP        
   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxjump.vim
" START Plugin
let s:curplugin='vimuiex#vxjump'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&has('python_screen'))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&python_screen: ' . s:StrHas('python,python_screen')
 else
  try        
   command VxLineJump call vimuiex#vxjump#VxLineJump()
   command VxWindowJump call vimuiex#vxjump#VxWindowJump()

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxlist.vim
" START Plugin
let s:curplugin='vimuiex#vxlist#init'
if s:ContinueLoading(s:curplugin)
 try        
  call s:CheckSetting('g:VxPopupListPos', '{}')
  call s:CheckSetting('g:_VxPopupListPosDefault', '{}')

  call s:SetLoaded(s:curplugin, 1)
 catch /.*/
  call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
 endtry
endif
" END Plugin

" ================================
" Source: vimuiex/vxoccur.vim
" START Plugin
let s:curplugin='vimuiex#vxoccur'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   call s:CheckSetting('g:vxoccur_routine_def', '{}')
   call s:CheckSetting('g:vxoccur_task_words', "['COMBAK', 'TODO', 'FIXME', 'XXX']")
   command VxOccur call vimuiex#vxoccur#VxOccur()
   command VxOccurCurrent call vimuiex#vxoccur#VxOccurCurrent()
   command VxOccurRoutines call vimuiex#vxoccur#VxOccurRoutines()
   command VxOccurTags call vimuiex#vxoccur#VxOccurTags()
   command VxSourceTasks call vimuiex#vxoccur#VxSourceTasks()

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxrecentfile.vim
" START Plugin
let s:curplugin='vimuiex#vxrecentfile'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   call s:CheckSetting('g:VxRecentFile_size', 50)
   call s:CheckSetting('g:VxRecentFile_exclude', '""')
   call s:CheckSetting('g:VxRecentFile_nocase', !has('fname_case'))

   function! s:VIMUIEX_recentfile_SaveHistory()
    let g:VXRECENTFILES = join(g:VxPluginVar.vxrecentfile_files, "\n")
   endfunc

   function! s:VIMUIEX_recentfile_AutoMRU(filename) " based on tmru.vim
    if ! has_key(g:VxPluginVar, 'vxrecentfile_files') | return | endif
    if &buflisted && &buftype !~ 'nofile' && fnamemodify(a:filename, ':t') != ''
     if g:VxRecentFile_exclude != '' && a:filename =~ g:VxRecentFile_exclude
      return
     endif
     let files = g:VxPluginVar.vxrecentfile_files
     let idx = index(files, a:filename, 0, g:VxRecentFile_nocase)
     if idx == -1 && len(files) >= g:VxRecentFile_size
      let idx = g:VxRecentFile_size - 1
     endif
     if idx > 0  | call remove(files, idx) | endif
     if idx != 0 | call insert(files, a:filename) | endif
    endif
   endf

   augroup vxrecentfile
    autocmd!
    autocmd BufWritePost,BufReadPost * call s:VIMUIEX_recentfile_AutoMRU(expand('<afile>:p'))
    autocmd VimLeavePre * call s:VIMUIEX_recentfile_SaveHistory()
   augroup END


   command VxOpenRecentFile call vimuiex#vxrecentfile#VxOpenRecentFile()
   " STARTUP
   function! s:G_vimuiex_vxrecentfile_auto_startup()
    try
     autocmd! G_vimuiex_vxrecentfile_auto_onetime        
     call s:CheckSetting('g:VXRECENTFILES', '""')
     let g:VxPluginVar.vxrecentfile_files = split(g:VXRECENTFILES, "\n")
    catch /.*/
     call s:Exception(v:throwpoint, v:exception, 'Startup: vimuiex#vxrecentfile', 0)
    endtry
   endfunc
   augroup G_vimuiex_vxrecentfile_auto_onetime
    autocmd!
    autocmd BufWinEnter,VimEnter *
       \ call s:G_vimuiex_vxrecentfile_auto_startup()
       \ | delfunc s:G_vimuiex_vxrecentfile_auto_startup
   augroup END
   " END-STARTUP        
   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxtextmenu.vim
" START Plugin
let s:curplugin='vimuiex#vxtextmenu'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   command VxTextMenu call vimuiex#vxtextmenu#VxTextMenu()

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
for err in s:exception_list
 echoerr err
endfor
let s:exception_list = []
