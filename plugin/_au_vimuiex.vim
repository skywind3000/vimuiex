" This file is autogenerated. DO NOT EDIT. Changes will be lost.
" Generator: vxlib/plugin.py
"if vxlib#plugin#StopLoading('_plugin_autogen_0b3344:a862')
"   finish
"endif


if !exists("g:vxlib_user_generated_plugins") || !g:vxlib_user_generated_plugins
 finish
endif

let s:exception_list = []

function! s:StrHas(ftrlist)
 let ftrs=split(a:ftrlist, ',')
 let hftrs=[]
 for f in ftrs
  call add(hftrs, (has(f) ? '+' : '-') . f)
 endfo
 return join(hftrs, ' ')
endfunc
function! s:Exception(throwpoint, exception, plugid, loadstatus)
 if a:loadstatus != 0
  call vxlib#plugin#SetLoaded(a:plugid, a:loadstatus)
 endif
 call add(s:exception_list, matchstr(a:throwpoint, ',\s*\zsline\s\+\d\+') . ' (' . a:plugid . '):')
 call add(s:exception_list, '   ' . a:exception)
 let g:VxPluginErrors[a:plugid] = a:exception
endfunc

function! s:CheckSetting(name, default)
 if !exists(a:name)
  exec 'let ' . a:name . '=' . a:default
 endif
endfunc

function! s:IsEnabled(name)
 return vxlib#plugin#IsEnabled(a:name)
endfunc

function! s:GetLoadStatus(name)
 return vxlib#plugin#GetLoadStatus(a:name)
endfunc

function! s:SetLoaded(name, value)
 return vxlib#plugin#SetLoaded(a:name, a:value)
endfunc

function! s:SetEnabledDefault(name, value)
 if ! has_key(g:VxPlugins, a:name) && ! exists("g:vxenabled_" . a:name)
  call vxlib#plugin#SetEnabled(a:name, a:value)
 endif
endfunc

function! s:ContinueLoading(name)
 if ! vxlib#plugin#IsEnabled(a:name)
  call vxlib#plugin#SetLoaded(a:name, -1)
 elseif ! vxlib#plugin#GetLoadStatus(a:name)
  return 1
 endif
 return 0
endfunc

" ================================
" Source: vimuiex/vxbuflist.vim
" START Plugin
let s:curplugin='vimuiex_vxbuflist'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   let g:VxPluginVar.vxbuflist_mru = []
   function s:VIMUIEX_buflist_pushBufNr(nr)
    " mru code adapted from tlib#buffer
    let lst = g:VxPluginVar.vxbuflist_mru
    let i = index(lst, a:nr)
    if i > 0  | call remove(lst, i) | endif
    if i != 0 | call insert(lst, a:nr) | endif
   endfunc

   augroup vxbuflist
    autocmd BufEnter * call s:VIMUIEX_buflist_pushBufNr(bufnr('%'))
   augroup END
   command VxBufListSelect call vimuiex#vxbuflist#VxBufListSelect()
   nmap <silent><unique> <Plug>VxBufListSelect :VxBufListSelect<cr>
   imap <silent><unique> <Plug>VxBufListSelect <Esc>:VxBufListSelect<cr>
   vmap <silent><unique> <Plug>VxBufListSelect :<c-u>VxBufListSelect<cr>

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxcapture.vim
" START Plugin
let s:curplugin='vimuiex_vxcapture'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   command -nargs=+ -complete=command VxCmd call vimuiex#vxcapture#VxCmd_QArgs(<q-args>)
   command VxMarks call vimuiex#vxcapture#VxMarks()
   command VxDisplay call vimuiex#vxcapture#VxDisplay()
   command -nargs=+ VxMan call vimuiex#vxcapture#VxMan_QArgs(<q-args>)
   nmap <silent><unique> <Plug>VxMarks :VxMarks<cr>
   imap <silent><unique> <Plug>VxMarks <Esc>:VxMarks<cr>
   vmap <silent><unique> <Plug>VxMarks :<c-u>VxMarks<cr>
   nmap <silent><unique> <Plug>VxDisplay :VxDisplay<cr>
   imap <silent><unique> <Plug>VxDisplay <Esc>:VxDisplay<cr>
   vmap <silent><unique> <Plug>VxDisplay :<c-u>VxDisplay<cr>

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxcmdhist.vim
" START Plugin
let s:curplugin='vimuiex_vxcmdhist'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   call s:CheckSetting('g:vxcmdhist_default_map', '1')
   if g:vxcmdhist_default_map
    cnoremap <pageup> <C-\>evimuiex#vxcmdhist#PopupHist()<cr>
    cnoremap <pagedown> <C-\>evimuiex#vxcmdhist#PopupHist()<cr>
   endif

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxdired.vim
" START Plugin
let s:curplugin='vimuiex_vxdired'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   call s:CheckSetting('g:VxRecentFile_nocase', !has('fname_case'))
   call s:CheckSetting('g:VxRecentDir_size', 20)
   call s:CheckSetting('g:VxFileFilter_treeDepth', 6)
   call s:CheckSetting('g:VxFileFilter_skipFiles', "'*.pyc,*.o,*.*~,*.~*,.*.swp'")
   call s:CheckSetting('g:VxFileFilter_skipDirs', "'.git,.svn'")
   call s:CheckSetting('g:VxFileFilter_limitCount', 0)
   call s:CheckSetting('g:VxFileBrowser_skipFiles', 'g:VxFileFilter_skipFiles')
   call s:CheckSetting('g:VxFileBrowser_skipDirs', "''")

   function! s:VIMUIEX_dired_SaveHistory()
    let g:VXRECENTDIRS = join(g:VxPluginVar.vxrecentfile_dirs, "\n")
   endfunc

   function! s:VIMUIEX_dired_AutoMRU(filename) " based on tmru.vim
    if ! has_key(g:VxPluginVar, 'vxrecentfile_dirs') | return | endif
    if &buflisted && &buftype !~ 'nofile' && fnamemodify(a:filename, ':t') != ''
     let dir = fnamemodify(a:filename, ':p:h')
     let dirs = g:VxPluginVar.vxrecentfile_dirs
     let idx = index(dirs, dir, 0, g:VxRecentFile_nocase)
     if idx == -1
      let rdirs = []
      for fnm in dirs
       call add(rdirs, resolve(fnm))
      endfor
      let rfname = resolve(dir)
      let idx = index(rdirs, rfname, 0, g:VxRecentFile_nocase)
     endif
     if idx == -1 && len(dirs) >= g:VxRecentDir_size
      let idx = g:VxRecentDir_size - 1
     endif
     if idx > 0  | call remove(dirs, idx) | endif
     if idx != 0 | call insert(dirs, dir) | endif
    endif
   endf

   augroup vxdired
    autocmd!
    autocmd BufWritePost,BufReadPost  * call s:VIMUIEX_dired_AutoMRU(expand('<afile>:p'))
    autocmd VimLeavePre * call s:VIMUIEX_dired_SaveHistory()
   augroup END


   command VxFileBrowser call vimuiex#vxdired#VxFileBrowser('browse')
   command VxFileFilter call vimuiex#vxdired#VxFileBrowser('filter')
   nmap <silent><unique> <Plug>VxFileBrowser :VxFileBrowser<cr>
   imap <silent><unique> <Plug>VxFileBrowser <Esc>:VxFileBrowser<cr>
   vmap <silent><unique> <Plug>VxFileBrowser :<c-u>VxFileBrowser<cr>
   nmap <silent><unique> <Plug>VxFileFilter :VxFileFilter<cr>
   imap <silent><unique> <Plug>VxFileFilter <Esc>:VxFileFilter<cr>
   vmap <silent><unique> <Plug>VxFileFilter :<c-u>VxFileFilter<cr>

   " STARTUP
   function! s:G_vimuiex_vxdired_auto_startup()
    try
     autocmd! G_vimuiex_vxdired_auto_onetime        
     call s:CheckSetting('g:VXRECENTDIRS', '""')
     let g:VxPluginVar.vxrecentfile_dirs = split(g:VXRECENTDIRS, "\n")
    catch /.*/
     call s:Exception(v:throwpoint, v:exception, 'Startup: vimuiex_vxdired', 0)
    endtry
   endfunc
   augroup G_vimuiex_vxdired_auto_onetime
    autocmd!
    autocmd BufWinEnter,VimEnter *
       \ call s:G_vimuiex_vxdired_auto_startup()
       \ | delfunc s:G_vimuiex_vxdired_auto_startup
   augroup END
   " END-STARTUP        
   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxjump.vim
" START Plugin
let s:curplugin='vimuiex_vxjump'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&has('python_screen'))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&python_screen: ' . s:StrHas('python,python_screen')
 else
  try        
   command VxLineJump call vimuiex#vxjump#VxLineJump()
   command VxWindowJump call vimuiex#vxjump#VxWindowJump()
   nmap <silent><unique> <Plug>VxLineJump :VxLineJump<cr>
   imap <silent><unique> <Plug>VxLineJump <Esc>:VxLineJump<cr>
   vmap <silent><unique> <Plug>VxLineJump :<c-u>VxLineJump<cr>
   nmap <silent><unique> <Plug>VxWindowJump :VxWindowJump<cr>
   imap <silent><unique> <Plug>VxWindowJump <Esc>:VxWindowJump<cr>
   vmap <silent><unique> <Plug>VxWindowJump :<c-u>VxWindowJump<cr>

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxlist.vim
" START Plugin
let s:curplugin='vimuiex_vxlist_init'
if s:ContinueLoading(s:curplugin)
 try        
  call s:CheckSetting('g:VxPopupListPos', '{}')
  call s:CheckSetting('g:_VxPopupListPosDefault', '{}')

  call s:SetLoaded(s:curplugin, 1)
 catch /.*/
  call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
 endtry
endif
" END Plugin

" ================================
" Source: vimuiex/vxmap.vim
" START Plugin
let s:curplugin='vimuiex_vxmap_quickkeys'
if s:ContinueLoading(s:curplugin)
 if !(has('menu'))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'menu: ' . s:StrHas('menu')
 else
  try        
   " use 'default' to append; use 'default!' to replace
   " each list item is: ['key', 'key', ...]
   call s:CheckSetting('g:vxmap_quick_keys', "{'default!': ['<F5>', '<F6>', '<F7>']}")

   " dictionary of lists; use 'default' to append; use 'default!' to replace
   " each list item is: ['menu entry', ['command', 'command', ...]]
   call s:CheckSetting('g:vxmap_quick_commands', "{'default': []}")

   " vimuiex/popup(/choice, not yet)
   call s:CheckSetting('g:vxmap_quick_menu', "'vimuiex'")

   nmap <silent><unique> <Plug>VxMapDefaultKeys :call vimuiex#vxmap#InstallKeys('default','default')<cr>
   imap <silent><unique> <Plug>VxMapDefaultKeys <Esc>:call vimuiex#vxmap#InstallKeys('default','default')<cr>
   vmap <silent><unique> <Plug>VxMapDefaultKeys <Esc>:call vimuiex#vxmap#InstallKeys('default','default')<cr>

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxoccur.vim
" START Plugin
let s:curplugin='vimuiex_vxoccur'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   call s:CheckSetting('g:vxoccur_routine_def', '{}')
   call s:CheckSetting('g:vxoccur_task_words', "['COMBAK', 'TODO', 'FIXME', 'XXX']")
   call s:CheckSetting('g:vxoccur_hist_size', '10')
   call s:CheckSetting('g:vxoccur_match_limit', '1000')
   " grep mode: 0 - vimgrep, 1 - grep (-r), 2 - find - xargs - grep
   call s:CheckSetting('g:vxoccur_grep_mode', '0')
   " variables used by grep.vim
   call s:CheckSetting('g:Grep_Path', "'grep'")
   call s:CheckSetting('g:Grep_Find_Path', "'find'")
   call s:CheckSetting('g:Grep_Xargs_Path', "'xargs'")

   command VxOccur call vimuiex#vxoccur#VxOccur()
   command VxOccurCurrent call vimuiex#vxoccur#VxOccurCurrent()
   command VxOccurRoutines call vimuiex#vxoccur#VxOccurRoutines()
   command VxOccurTags call vimuiex#vxoccur#VxOccurTags()
   command VxSourceTasks call vimuiex#vxoccur#VxSourceTasks()
   command VxOccurHist call vimuiex#vxoccur#VxShowLastCapture(v:count)
   command VxOccurSelectHist call vimuiex#vxoccur#VxSelectOccurHist()
   command VxCNext call vimuiex#vxoccur#VxCNext(1)
   command VxCPrev call vimuiex#vxoccur#VxCNext(-1)

   function! s:F_vx_occur_map_plug_(vxcmd)
    silent exec 'nmap <unique> <Plug>' . a:vxcmd . ' :' . a:vxcmd . '<cr>'
    silent exec 'imap <unique> <Plug>' . a:vxcmd . ' <Esc>:' . a:vxcmd . '<cr>'
    silent exec 'vmap <unique> <Plug>' . a:vxcmd . ' :<c-u>' . a:vxcmd . '<cr>'
   endfunc
   call s:F_vx_occur_map_plug_('VxOccurCurrent')
   call s:F_vx_occur_map_plug_('VxOccurRoutines')
   call s:F_vx_occur_map_plug_('VxOccurTags')
   call s:F_vx_occur_map_plug_('VxSourceTasks')
   call s:F_vx_occur_map_plug_('VxCNext')
   call s:F_vx_occur_map_plug_('VxCPrev')
   call s:F_vx_occur_map_plug_('VxOccurSelectHist')
   delfunction s:F_vx_occur_map_plug_

   nmap <unique> <Plug>VxOccurHist :<c-u>VxOccurHist<cr>
   imap <unique> <Plug>VxOccurHist <Esc>:<c-u>VxOccurHist<cr>
   vmap <unique> <Plug>VxOccurHist :<c-u>VxOccurHist<cr>
   nmap <unique> <Plug>VxOccurRegex :<c-u>VxOccur<cr>
   imap <unique> <Plug>VxOccurRegex <Esc>:<c-u>VxOccur<cr>
   vmap <unique> <Plug>VxOccurRegex :<c-u>VxOccur<cr>

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxrecentfile.vim
" START Plugin
let s:curplugin='vimuiex_vxrecentfile'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   call s:CheckSetting('g:VxRecentFile_size', 50)
   call s:CheckSetting('g:VxRecentFile_exclude', '""')
   call s:CheckSetting('g:VxRecentFile_nocase', !has('fname_case'))

   function! s:VIMUIEX_recentfile_SaveHistory()
    let g:VXRECENTFILES = join(g:VxPluginVar.vxrecentfile_files, "\n")
   endfunc

   function! s:VIMUIEX_recentfile_AutoMRU(filename) " based on tmru.vim
    if ! has_key(g:VxPluginVar, 'vxrecentfile_files') | return | endif
    if &buflisted && &buftype !~ 'nofile' && fnamemodify(a:filename, ':t') != ''
     if g:VxRecentFile_exclude != '' && a:filename =~ g:VxRecentFile_exclude
      return
     endif
     let files = g:VxPluginVar.vxrecentfile_files
     let idx = index(files, a:filename, 0, g:VxRecentFile_nocase)
     if idx == -1
      let rfiles = []
      for fnm in files
       call add(rfiles, resolve(fnm))
      endfor
      let rfname = resolve(a:filename)
      let idx = index(rfiles, rfname, 0, g:VxRecentFile_nocase)
     endif
     if idx == -1 && len(files) >= g:VxRecentFile_size
      let idx = g:VxRecentFile_size - 1
     endif
     if idx > 0  | call remove(files, idx) | endif
     if idx != 0 | call insert(files, a:filename) | endif
    endif
   endf

   augroup vxrecentfile
    autocmd!
    autocmd BufWritePost,BufReadPost * call s:VIMUIEX_recentfile_AutoMRU(expand('<afile>:p'))
    autocmd VimLeavePre * call s:VIMUIEX_recentfile_SaveHistory()
   augroup END


   command VxOpenRecentFile call vimuiex#vxrecentfile#VxOpenRecentFile()
   nmap <silent><unique> <Plug>VxOpenRecentFile :VxOpenRecentFile<cr>
   imap <silent><unique> <Plug>VxOpenRecentFile <Esc>:VxOpenRecentFile<cr>
   vmap <silent><unique> <Plug>VxOpenRecentFile :<c-u>VxOpenRecentFile<cr>
   " STARTUP
   function! s:G_vimuiex_vxrecentfile_auto_startup()
    try
     autocmd! G_vimuiex_vxrecentfile_auto_onetime        
     call s:CheckSetting('g:VXRECENTFILES', '""')
     let g:VxPluginVar.vxrecentfile_files = split(g:VXRECENTFILES, "\n")
    catch /.*/
     call s:Exception(v:throwpoint, v:exception, 'Startup: vimuiex_vxrecentfile', 0)
    endtry
   endfunc
   augroup G_vimuiex_vxrecentfile_auto_onetime
    autocmd!
    autocmd BufWinEnter,VimEnter *
       \ call s:G_vimuiex_vxrecentfile_auto_startup()
       \ | delfunc s:G_vimuiex_vxrecentfile_auto_startup
   augroup END
   " END-STARTUP        
   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
" Source: vimuiex/vxtextmenu.vim
" START Plugin
let s:curplugin='vimuiex_vxtextmenu'
if s:ContinueLoading(s:curplugin)
 if !(has('python')&&(!has('gui_running')||has('python_screen')))
  call s:SetLoaded(s:curplugin, -2)
  let g:VxPluginMissFeatures[s:curplugin] = 'python&&(!gui_running||python_screen): ' . s:StrHas('gui_running,python,python_screen')
 else
  try        
   command VxTextMenu call vimuiex#vxtextmenu#VxTextMenu('','n')
   nmap <silent><unique> <Plug>VxTextMenu :call vimuiex#vxtextmenu#VxTextMenu('','n')<cr>
   imap <silent><unique> <Plug>VxTextMenu <Esc>:call vimuiex#vxtextmenu#VxTextMenu('','i')<cr>
   vmap <silent><unique> <Plug>VxTextMenu :<c-u>call vimuiex#vxtextmenu#VxTextMenu('','v',visualmode())<cr>

   call s:SetLoaded(s:curplugin, 1)
  catch /.*/
   call s:Exception(v:throwpoint, v:exception, s:curplugin, -9)
  endtry
 endif
endif
" END Plugin

" ================================
for err in s:exception_list
 echoerr err
endfor
let s:exception_list = []
