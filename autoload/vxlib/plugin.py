#!/usr/bin/env python
# vim:set fileencoding=utf-8 sw=4 ts=8 et:vim
#
# Author:  Marko Mahniƒç
# Created: October 2009 
# License: GPL (http://www.gnu.org/copyleft/gpl.html)
# This program comes with ABSOLUTELY NO WARRANTY.

import os, sys, stat
import shutil
import optparse
import re, string
import datetime

options = None

separator = '''" ================================'''
file_head = '''\
" This file is autogenerated. DO NOT EDIT. Changes will be lost.
" Generator: vxlib/plugin.py
"if vxlib#plugin#StopLoading('_plugin_autogen_${timestamp}')
"   finish
"endif

let s:exception_list = []
function! s:Exception(throwpoint, exception, plugid)
   call add(s:exception_list, matchstr(a:throwpoint, ',\s*\zsline\s\+\d\+') . ' (' . a:plugid . '):')
   call add(s:exception_list, '   ' . a:exception)
   let g:VxPluginErrors[a:plugid] = a:exception
endfunc

function! s:StrHas(ftrlist)
   let ftrs=split(a:ftrlist, ',')
   let hftrs=[]
   for f in ftrs
       call add(hftrs, (has(f) ? '+' : '-') . f)
   endfo
   return join(hftrs, ' ')
endfunc\
'''
plugin_proxies='''
function! s:CheckSetting(name, default)
   call vxlib#plugin#CheckSetting(a:name, a:default)
endfunc

function! s:IsEnabled(name)
   return vxlib#plugin#IsEnabled(a:name)
endfunc

function! s:GetLoadStatus(name)
   return vxlib#plugin#GetLoadStatus(a:name)
endfunc

function! s:SetLoaded(name, value)
   return vxlib#plugin#SetLoaded(a:name, a:value)
endfunc

function! s:ContinueLoading(name)
   if ! vxlib#plugin#IsEnabled(a:name)
      call vxlib#plugin#SetLoaded(a:name, -1)
   elseif ! vxlib#plugin#GetLoadStatus(a:name)
      return 1
   endif
   return 0
endfunc
'''
file_tail ='''\
for err in s:exception_list
   echoerr err
endfor
let s:exception_list = []
'''

# Calling echoerr from autocmd locks (g)vim.
this_tail_not_working = '''
function! s:NotifyErrors()
   autocmd! G_Notify_Errors_onetime
   echoerr 'This is a test'
endfunc
augroup G_Notify_Errors_onetime
  autocmd!
  autocmd BufWinEnter,VimEnter *
     \ call s:NotifyErrors() | delfunc s:NotifyErrors
augroup END
'''

#plugin_head = """\
#" Source: ${filename}
#" START Plugin
#if ! ${vxlib_plugin}IsEnabled("${plugin}")
#   call ${vxlib_plugin}SetLoaded("${plugin}", -1)
#else
#${if_require}\
# if ! ${vxlib_plugin}GetLoadStatus("${plugin}")
#  try\
#"""
#if_require_str="""\
# if !(%s)
#   call ${vxlib_plugin}SetLoaded("${plugin}", -2)
#   let g:VxPluginMissFeatures["${plugin}"] = "${require_expr}: " ${require_status}
# endif
#"""
#plugin_tail = """\
#   call ${vxlib_plugin}SetLoaded("${plugin}", 1)
#  catch /.*/
#   call ${vxlib_plugin}SetLoaded("${plugin}", -9)
#   call s:Exception(v:throwpoint, v:exception, "${plugin}")
#  endtry
# endif
#endif
#" END Plugin
#"""

plugin_head = """\
" Source: ${filename}
" START Plugin
if s:ContinueLoading('${plugin}')
${if_require}\
  try\
"""
if_require_str="""\
 if !(%s)
   call ${vxlib_plugin}SetLoaded('${plugin}', -2)
   let g:VxPluginMissFeatures['${plugin}'] = '${require_expr}: ' ${require_status}
 else
"""
endif_require_str="""\
 endif
"""
plugin_tail = """\
   call ${vxlib_plugin}SetLoaded('${plugin}', 1)
  catch /.*/
   call ${vxlib_plugin}SetLoaded('${plugin}', -9)
   call s:Exception(v:throwpoint, v:exception, '${plugin}')
  endtry
${endif_require}\
endif
" END Plugin
"""

startup_head = """\
   " STARTUP
   function! s:G_${plugin}_auto_startup()
    try
      autocmd! G_${plugin}_auto_onetime\
"""
startup_tail = """\
    catch /.*/
      call s:Exception(v:throwpoint, v:exception, 'Startup: ${plugin}')
    endtry
   endfunc
   augroup G_${plugin}_auto_onetime
      autocmd!
      autocmd BufWinEnter,VimEnter *
         \ call s:G_${plugin}_auto_startup()
         \ | delfunc s:G_${plugin}_auto_startup
   augroup END
   " END-STARTUP\
"""

# how to call vxlib#plugin functions (with local proxy or directly)
vxlib_plugin = "s:"
# vxlib_plugin = "vxlib#plugin#"

class CStdout:
    def write(self, str):
        print str

class State:
    def __init__(self, filename):
        self.filename = filename
        self.f = open(filename)
        self.pluginTag = ""
        self.pluginId = ""
        self.pluginAttrs = "" # except id

    @property
    def pluginVarname(self):
        return re.sub("[^a-zA-Z0-9_]", "_", self.pluginId)

    @property
    def shortFilename(self):
        p = os.path
        return p.join(p.basename(p.dirname(self.filename)), p.basename(self.filename))
    
def parseStartup(state, out):
    data = { "plugin": state.pluginVarname }
    out.write(string.Template(startup_head).substitute(data))
    while True:
        ln = state.f.readline()
        if ln == "": break
        mo = re.match(r'''\s*"\s*</STARTUP>''', ln)
        if mo != None:
            out.write(string.Template(startup_tail).substitute(data))
            return ln
        out.write(ln.rstrip())
    if ln == None or ln == "": return None # Notify EOF
    return ln

def buildRequire(expr):
    global options
    if not options.add_require:
        return ("", "")
    expr = expr.replace('"', '').replace("'", "")
    haspat = """has('%s')"""
    ifexpr = ""; hasexpr = ""; prev = 0
    features = {}
    for mo in re.finditer(r'''[()!]|(\&\&)|(\|\|)''', expr):
        text = expr[prev:mo.start()].strip()
        if text != "":
            ifexpr += haspat % text
            features[text] = 1
        ifexpr += mo.group(0)
        prev = mo.end()
    text = expr[prev:].strip()
    if text != "":
        ifexpr += haspat % text
        features[text] = 1
    #for text in sorted(features.keys()):
    #    hasexpr += ''' . ", %s=" . %s''' % (text, haspat % text)
    hasexpr = '''. s:StrHas('%s')''' % (",".join(sorted(features.keys())))

    if ifexpr == "": return ("", "")
    else: return (if_require_str % ifexpr, hasexpr)

def parsePlugin(state, blockLine, moPlugin, out):
    data = {
        "vxlib_plugin": vxlib_plugin,
        "plugin": state.pluginId,
        "filename": state.shortFilename
    }

    mo = re.search(r'''\brequire\s*=\s*["']([^"']+)["']''', state.pluginAttrs)
    if mo == None: require = ""
    else:
        require, has_status = buildRequire(mo.group(1))
        data["require_expr"] = mo.group(1).replace(" ", "")
        data["require_status"] = has_status
    require = string.Template(require).substitute(data)
    data["if_require"] = require
    if require == "": data["endif_require"] = ""
    else: data["endif_require"] = endif_require_str

    out.write(string.Template(plugin_head).substitute(data))
    while True:
        ln = state.f.readline()
        if ln == "": break
        mo = re.match(r'''\s*"\s*</VIMPLUGIN>''', ln)
        if mo != None:
            out.write(string.Template(plugin_tail).substitute(data))
            return ln
        mo = re.match(r'''\s*"\s*<STARTUP>''', ln)
        if mo != None:
            ln = parseStartup(state, out)
            if ln == None: break
            continue
        out.write(ln.rstrip())
    if ln == None or ln == "": return None # Notify EOF
    return ln

def parseFile(fn, out):
    state = State(fn)
    firstTime = True
    while True:
        ln = state.f.readline()
        if ln == "": break
        ln = ln.rstrip()
        mo = re.match(r'''\s*"\s*<VIMPLUGIN\s+id\s*=\s*["']([^"']+)["']([^>]*)>''', ln)
        if mo != None:
            if firstTime:
                out.write(separator)
                firstTime = False
            state.pluginId = mo.group(1)
            state.pluginAttrs = mo.group(2)
            state.pluginTag = ln
            ln = parsePlugin(state, ln, mo, out)
            if ln == None: break
            continue
    state.f.close()

def readOptions():
    usage = "Usage: %prog [options] args"
    parser = optparse.OptionParser(usage)

    parser.add_option("-v", "--verbose", action="store", type="int", dest="verbose")
    parser.add_option("-q", "--quiet", action="store_const", const=0, dest="verbose")
    parser.add_option("", "--no-require", action="store_const", const=0, dest="add_require", default=1)

    (options, args) = parser.parse_args()
    if options.verbose > 3: print "Options parsed"
    if len(args) < 1: parser.error("No files specifed.")
    return (options, args)

def walktree(top, callback):
    for f in os.listdir(top):
        pathname = os.path.join(top, f)
        mode = os.stat(pathname)[stat.ST_MODE]
        if stat.S_ISDIR(mode): walktree(pathname, callback)
        elif stat.S_ISREG(mode): callback(pathname)

def getFileList(args):
    files = []
    def addFile(fn):
        fn = os.path.abspath(fn)
        if not fn in files: files.append(fn)
    for fsp in args:
        mode = os.stat(fsp)[stat.ST_MODE]
        if stat.S_ISDIR(mode): walktree(fsp, addFile)
        elif stat.S_ISREG(mode): addFile(fsp)
    return files

def main():
    global options
    options, args = readOptions()
    lst = getFileList(args)
    if len(lst) < 1:
        print "No files to process."
        return

    out = CStdout()
    now = datetime.datetime.utcnow()
    dt = "%06x:%04x" % (now.toordinal(), now.hour * 3600 + now.minute * 60 + now.second)
    out.write(string.Template(file_head).substitute({"timestamp": dt}))
    out.write(plugin_proxies)
    for fn in lst:
        if fn.endswith(".vim"):
            parseFile(fn, out)

    out.write(separator)
    out.write(file_tail)

if __name__ == "__main__":
    main()
